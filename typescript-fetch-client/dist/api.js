"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * quantimodo
 * We make it easy to retrieve and analyze normalized user data from a wide array of devices and applications. Check out our [docs and sdk's](https://github.com/QuantiModo/docs) or [contact us](https://help.quantimo.do).
 *
 * OpenAPI spec version: 5.8.112511
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
const portableFetch = require("portable-fetch");
const BASE_PATH = "https://app.quantimo.do/api".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = portableFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * ActivitiesApi - fetch parameter creator
 * @export
 */
exports.ActivitiesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get Activities
         * @summary Get Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post Activities
         * @summary Post Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/activities`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActivitiesApi - functional programming interface
 * @export
 */
exports.ActivitiesApiFp = function (configuration) {
    return {
        /**
         * Get Activities
         * @summary Get Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.ActivitiesApiFetchParamCreator(configuration).getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post Activities
         * @summary Post Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.ActivitiesApiFetchParamCreator(configuration).postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ActivitiesApi - factory interface
 * @export
 */
exports.ActivitiesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get Activities
         * @summary Get Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.ActivitiesApiFp(configuration).getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post Activities
         * @summary Post Activities
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.ActivitiesApiFp(configuration).postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};
/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
class ActivitiesApi extends BaseAPI {
    /**
     * Get Activities
     * @summary Get Activities
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.ActivitiesApiFp(this.configuration).getActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post Activities
     * @summary Post Activities
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.ActivitiesApiFp(this.configuration).postActivities(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
}
exports.ActivitiesApi = ActivitiesApi;
/**
 * AnalyticsApi - fetch parameter creator
 * @export
 */
exports.AnalyticsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get explanations of  correlations based on data from a single user.
         * @summary Get correlation explanations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options = {}) {
            const localVarPath = `/v3/correlations/explanations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
         * @summary Get correlations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [commonOnly] Return only public, anonymized and aggregated population data instead of user-specific variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options = {}) {
            const localVarPath = `/v3/correlations`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (correlationCoefficient !== undefined) {
                localVarQueryParameter['correlationCoefficient'] = correlationCoefficient;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (outcomesOfInterest !== undefined) {
                localVarQueryParameter['outcomesOfInterest'] = outcomesOfInterest;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (commonOnly !== undefined) {
                localVarQueryParameter['commonOnly'] = commonOnly;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AnalyticsApi - functional programming interface
 * @export
 */
exports.AnalyticsApiFp = function (configuration) {
    return {
        /**
         * Get explanations of  correlations based on data from a single user.
         * @summary Get correlation explanations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options) {
            const localVarFetchArgs = exports.AnalyticsApiFetchParamCreator(configuration).getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
         * @summary Get correlations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [commonOnly] Return only public, anonymized and aggregated population data instead of user-specific variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options) {
            const localVarFetchArgs = exports.AnalyticsApiFetchParamCreator(configuration).getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AnalyticsApi - factory interface
 * @export
 */
exports.AnalyticsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get explanations of  correlations based on data from a single user.
         * @summary Get correlation explanations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options) {
            return exports.AnalyticsApiFp(configuration).getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options)(fetch, basePath);
        },
        /**
         * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
         * @summary Get correlations
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [commonOnly] Return only public, anonymized and aggregated population data instead of user-specific variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options) {
            return exports.AnalyticsApiFp(configuration).getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options)(fetch, basePath);
        },
    };
};
/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
class AnalyticsApi extends BaseAPI {
    /**
     * Get explanations of  correlations based on data from a single user.
     * @summary Get correlation explanations
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options) {
        return exports.AnalyticsApiFp(this.configuration).getCorrelationExplanations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of correlations that can be used to display top predictors of a given outcome like mood, for instance.
     * @summary Get correlations
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {number} [userId] User&#39;s id
     * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [commonOnly] Return only public, anonymized and aggregated population data instead of user-specific variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options) {
        return exports.AnalyticsApiFp(this.configuration).getCorrelations(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, commonOnly, options)(this.fetch, this.basePath);
    }
}
exports.AnalyticsApi = AnalyticsApi;
/**
 * AppSettingsApi - fetch parameter creator
 * @export
 */
exports.AppSettingsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get the settings for your application configurable at https://build.quantimo.do
         * @summary Get client app settings
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppSettings(clientId, clientSecret, options = {}) {
            const localVarPath = `/v3/appSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (clientSecret !== undefined) {
                localVarQueryParameter['client_secret'] = clientSecret;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AppSettingsApi - functional programming interface
 * @export
 */
exports.AppSettingsApiFp = function (configuration) {
    return {
        /**
         * Get the settings for your application configurable at https://build.quantimo.do
         * @summary Get client app settings
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppSettings(clientId, clientSecret, options) {
            const localVarFetchArgs = exports.AppSettingsApiFetchParamCreator(configuration).getAppSettings(clientId, clientSecret, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AppSettingsApi - factory interface
 * @export
 */
exports.AppSettingsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get the settings for your application configurable at https://build.quantimo.do
         * @summary Get client app settings
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppSettings(clientId, clientSecret, options) {
            return exports.AppSettingsApiFp(configuration).getAppSettings(clientId, clientSecret, options)(fetch, basePath);
        },
    };
};
/**
 * AppSettingsApi - object-oriented interface
 * @export
 * @class AppSettingsApi
 * @extends {BaseAPI}
 */
class AppSettingsApi extends BaseAPI {
    /**
     * Get the settings for your application configurable at https://build.quantimo.do
     * @summary Get client app settings
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppSettingsApi
     */
    getAppSettings(clientId, clientSecret, options) {
        return exports.AppSettingsApiFp(this.configuration).getAppSettings(clientId, clientSecret, options)(this.fetch, this.basePath);
    }
}
exports.AppSettingsApi = AppSettingsApi;
/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
exports.AuthenticationApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
         * @summary Get a user access token
         * @param {string} grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
         * @param {string} code Authorization code you received with the previous request.
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options = {}) {
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType', 'Required parameter grantType was null or undefined when calling getAccessToken.');
            }
            // verify required parameter 'code' is not null or undefined
            if (code === null || code === undefined) {
                throw new RequiredError('code', 'Required parameter code was null or undefined when calling getAccessToken.');
            }
            // verify required parameter 'responseType' is not null or undefined
            if (responseType === null || responseType === undefined) {
                throw new RequiredError('responseType', 'Required parameter responseType was null or undefined when calling getAccessToken.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope', 'Required parameter scope was null or undefined when calling getAccessToken.');
            }
            const localVarPath = `/v3/oauth2/token`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (clientSecret !== undefined) {
                localVarQueryParameter['client_secret'] = clientSecret;
            }
            if (grantType !== undefined) {
                localVarQueryParameter['grant_type'] = grantType;
            }
            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }
            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }
            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
         * @summary Request Authorization Code
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options = {}) {
            // verify required parameter 'responseType' is not null or undefined
            if (responseType === null || responseType === undefined) {
                throw new RequiredError('responseType', 'Required parameter responseType was null or undefined when calling getOauthAuthorizationCode.');
            }
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope', 'Required parameter scope was null or undefined when calling getOauthAuthorizationCode.');
            }
            const localVarPath = `/v3/oauth2/authorize`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (clientSecret !== undefined) {
                localVarQueryParameter['client_secret'] = clientSecret;
            }
            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }
            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }
            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }
            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post GoogleIdToken
         * @summary Post GoogleIdToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGoogleIdToken(options = {}) {
            const localVarPath = `/v3/googleIdToken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
exports.AuthenticationApiFp = function (configuration) {
    return {
        /**
         * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
         * @summary Get a user access token
         * @param {string} grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
         * @param {string} code Authorization code you received with the previous request.
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options) {
            const localVarFetchArgs = exports.AuthenticationApiFetchParamCreator(configuration).getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
         * @summary Request Authorization Code
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options) {
            const localVarFetchArgs = exports.AuthenticationApiFetchParamCreator(configuration).getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post GoogleIdToken
         * @summary Post GoogleIdToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGoogleIdToken(options) {
            const localVarFetchArgs = exports.AuthenticationApiFetchParamCreator(configuration).postGoogleIdToken(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * AuthenticationApi - factory interface
 * @export
 */
exports.AuthenticationApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
         * @summary Get a user access token
         * @param {string} grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
         * @param {string} code Authorization code you received with the previous request.
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options) {
            return exports.AuthenticationApiFp(configuration).getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options)(fetch, basePath);
        },
        /**
         * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
         * @summary Request Authorization Code
         * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
         * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
         * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
         * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options) {
            return exports.AuthenticationApiFp(configuration).getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options)(fetch, basePath);
        },
        /**
         * Post GoogleIdToken
         * @summary Post GoogleIdToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGoogleIdToken(options) {
            return exports.AuthenticationApiFp(configuration).postGoogleIdToken(options)(fetch, basePath);
        },
    };
};
/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
class AuthenticationApi extends BaseAPI {
    /**
     * Client provides authorization token obtained from /api/v3/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query API endpoints. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v1/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v1/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v1/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)
     * @summary Get a user access token
     * @param {string} grantType Grant Type can be &#39;authorization_code&#39; or &#39;refresh_token&#39;
     * @param {string} code Authorization code you received with the previous request.
     * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
     * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
     * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options) {
        return exports.AuthenticationApiFp(this.configuration).getAccessToken(grantType, code, responseType, scope, clientId, clientSecret, redirectUri, state, options)(this.fetch, this.basePath);
    }
    /**
     * You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v3/oauth2/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v1/oauth/access_token endpoint for the next steps.
     * @summary Request Authorization Code
     * @param {string} responseType If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.
     * @param {string} scope Scopes include basic, readmeasurements, and writemeasurements. The &#x60;basic&#x60; scope allows you to read user info (displayName, email, etc). The &#x60;readmeasurements&#x60; scope allows one to read a user&#39;s data. The &#x60;writemeasurements&#x60; scope allows you to write user data. Separate multiple scopes by a space.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [clientSecret] This is the secret for your obtained clientId. We use this to ensure that only your application uses the clientId.  Obtain this by creating a free application at [https://builder.quantimo.do](https://builder.quantimo.do).
     * @param {string} [redirectUri] The redirect URI is the URL within your client application that will receive the OAuth2 credentials.
     * @param {string} [state] An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options) {
        return exports.AuthenticationApiFp(this.configuration).getOauthAuthorizationCode(responseType, scope, clientId, clientSecret, redirectUri, state, options)(this.fetch, this.basePath);
    }
    /**
     * Post GoogleIdToken
     * @summary Post GoogleIdToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    postGoogleIdToken(options) {
        return exports.AuthenticationApiFp(this.configuration).postGoogleIdToken(options)(this.fetch, this.basePath);
    }
}
exports.AuthenticationApi = AuthenticationApi;
/**
 * ConnectorsApi - fetch parameter creator
 * @export
 */
exports.ConnectorsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
         * @summary Obtain a token from 3rd party data source
         * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectConnector(connectorName, userId, options = {}) {
            // verify required parameter 'connectorName' is not null or undefined
            if (connectorName === null || connectorName === undefined) {
                throw new RequiredError('connectorName', 'Required parameter connectorName was null or undefined when calling connectConnector.');
            }
            const localVarPath = `/v3/connectors/{connectorName}/connect`
                .replace(`{${"connectorName"}}`, encodeURIComponent(String(connectorName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The disconnect method deletes any stored tokens or connection information from the connectors database.
         * @summary Delete stored connection info
         * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectConnector(connectorName, options = {}) {
            // verify required parameter 'connectorName' is not null or undefined
            if (connectorName === null || connectorName === undefined) {
                throw new RequiredError('connectorName', 'Required parameter connectorName was null or undefined when calling disconnectConnector.');
            }
            const localVarPath = `/v3/connectors/{connectorName}/disconnect`
                .replace(`{${"connectorName"}}`, encodeURIComponent(String(connectorName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
         * @summary List of Connectors
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(clientId, options = {}) {
            const localVarPath = `/v3/connectors/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
         * @summary Get embeddable connect javascript
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationJs(clientId, options = {}) {
            const localVarPath = `/v3/integration.js`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
         * @summary Mobile connect page
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMobileConnectPage(userId, options = {}) {
            const localVarPath = `/v3/connect/mobile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
         * @summary Sync with data source
         * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector(connectorName, userId, options = {}) {
            // verify required parameter 'connectorName' is not null or undefined
            if (connectorName === null || connectorName === undefined) {
                throw new RequiredError('connectorName', 'Required parameter connectorName was null or undefined when calling updateConnector.');
            }
            const localVarPath = `/v3/connectors/{connectorName}/update`
                .replace(`{${"connectorName"}}`, encodeURIComponent(String(connectorName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ConnectorsApi - functional programming interface
 * @export
 */
exports.ConnectorsApiFp = function (configuration) {
    return {
        /**
         * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
         * @summary Obtain a token from 3rd party data source
         * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectConnector(connectorName, userId, options) {
            const localVarFetchArgs = exports.ConnectorsApiFetchParamCreator(configuration).connectConnector(connectorName, userId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The disconnect method deletes any stored tokens or connection information from the connectors database.
         * @summary Delete stored connection info
         * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectConnector(connectorName, options) {
            const localVarFetchArgs = exports.ConnectorsApiFetchParamCreator(configuration).disconnectConnector(connectorName, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
         * @summary List of Connectors
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(clientId, options) {
            const localVarFetchArgs = exports.ConnectorsApiFetchParamCreator(configuration).getConnectors(clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
         * @summary Get embeddable connect javascript
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationJs(clientId, options) {
            const localVarFetchArgs = exports.ConnectorsApiFetchParamCreator(configuration).getIntegrationJs(clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
         * @summary Mobile connect page
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMobileConnectPage(userId, options) {
            const localVarFetchArgs = exports.ConnectorsApiFetchParamCreator(configuration).getMobileConnectPage(userId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
         * @summary Sync with data source
         * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector(connectorName, userId, options) {
            const localVarFetchArgs = exports.ConnectorsApiFetchParamCreator(configuration).updateConnector(connectorName, userId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * ConnectorsApi - factory interface
 * @export
 */
exports.ConnectorsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
         * @summary Obtain a token from 3rd party data source
         * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectConnector(connectorName, userId, options) {
            return exports.ConnectorsApiFp(configuration).connectConnector(connectorName, userId, options)(fetch, basePath);
        },
        /**
         * The disconnect method deletes any stored tokens or connection information from the connectors database.
         * @summary Delete stored connection info
         * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnectConnector(connectorName, options) {
            return exports.ConnectorsApiFp(configuration).disconnectConnector(connectorName, options)(fetch, basePath);
        },
        /**
         * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
         * @summary List of Connectors
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConnectors(clientId, options) {
            return exports.ConnectorsApiFp(configuration).getConnectors(clientId, options)(fetch, basePath);
        },
        /**
         * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
         * @summary Get embeddable connect javascript
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntegrationJs(clientId, options) {
            return exports.ConnectorsApiFp(configuration).getIntegrationJs(clientId, options)(fetch, basePath);
        },
        /**
         * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
         * @summary Mobile connect page
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMobileConnectPage(userId, options) {
            return exports.ConnectorsApiFp(configuration).getMobileConnectPage(userId, options)(fetch, basePath);
        },
        /**
         * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
         * @summary Sync with data source
         * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnector(connectorName, userId, options) {
            return exports.ConnectorsApiFp(configuration).updateConnector(connectorName, userId, options)(fetch, basePath);
        },
    };
};
/**
 * ConnectorsApi - object-oriented interface
 * @export
 * @class ConnectorsApi
 * @extends {BaseAPI}
 */
class ConnectorsApi extends BaseAPI {
    /**
     * Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.
     * @summary Obtain a token from 3rd party data source
     * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    connectConnector(connectorName, userId, options) {
        return exports.ConnectorsApiFp(this.configuration).connectConnector(connectorName, userId, options)(this.fetch, this.basePath);
    }
    /**
     * The disconnect method deletes any stored tokens or connection information from the connectors database.
     * @summary Delete stored connection info
     * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    disconnectConnector(connectorName, options) {
        return exports.ConnectorsApiFp(this.configuration).disconnectConnector(connectorName, options)(this.fetch, this.basePath);
    }
    /**
     * A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.
     * @summary List of Connectors
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    getConnectors(clientId, options) {
        return exports.ConnectorsApiFp(this.configuration).getConnectors(clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Get embeddable connect javascript. Usage:   - Embedding in applications with popups for 3rd-party authentication windows.     Use `qmSetupInPopup` function after connecting `connect.js`.   - Embedding in applications with popups for 3rd-party authentication windows.     Requires a selector to block. It will be embedded in this block.     Use `qmSetupOnPage` function after connecting `connect.js`.   - Embedding in mobile applications without popups for 3rd-party authentication.     Use `qmSetupOnMobile` function after connecting `connect.js`.     If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.
     * @summary Get embeddable connect javascript
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    getIntegrationJs(clientId, options) {
        return exports.ConnectorsApiFp(this.configuration).getIntegrationJs(clientId, options)(this.fetch, this.basePath);
    }
    /**
     * This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v3/connect/mobile?access_token=123
     * @summary Mobile connect page
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    getMobileConnectPage(userId, options) {
        return exports.ConnectorsApiFp(this.configuration).getMobileConnectPage(userId, options)(this.fetch, this.basePath);
    }
    /**
     * The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.
     * @summary Sync with data source
     * @param {string} connectorName Options: facebook, fitbit, github, googlecalendar, googlefit, medhelper, mint, moodpanda, moodscope, myfitnesspal, mynetdiary, netatmo, rescuetime, runkeeper, slack, sleepcloud, slice, up, whatpulse, withings, worldweatheronline, foursquare, strava, gmail
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConnectorsApi
     */
    updateConnector(connectorName, userId, options) {
        return exports.ConnectorsApiFp(this.configuration).updateConnector(connectorName, userId, options)(this.fetch, this.basePath);
    }
}
exports.ConnectorsApi = ConnectorsApi;
/**
 * FeedApi - fetch parameter creator
 * @export
 */
exports.FeedApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Tracking reminder notifications, messages, and study results
         * @summary Tracking reminder notifications, messages, and study results
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options = {}) {
            const localVarPath = `/v3/feed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post user actions on feed cards
         * @summary Post user interactions with feed
         * @param {Array<Card>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeed(body, userId, clientId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postFeed.');
            }
            const localVarPath = `/v3/feed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Card&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FeedApi - functional programming interface
 * @export
 */
exports.FeedApiFp = function (configuration) {
    return {
        /**
         * Tracking reminder notifications, messages, and study results
         * @summary Tracking reminder notifications, messages, and study results
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options) {
            const localVarFetchArgs = exports.FeedApiFetchParamCreator(configuration).getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post user actions on feed cards
         * @summary Post user interactions with feed
         * @param {Array<Card>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeed(body, userId, clientId, options) {
            const localVarFetchArgs = exports.FeedApiFetchParamCreator(configuration).postFeed(body, userId, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * FeedApi - factory interface
 * @export
 */
exports.FeedApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Tracking reminder notifications, messages, and study results
         * @summary Tracking reminder notifications, messages, and study results
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options) {
            return exports.FeedApiFp(configuration).getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options)(fetch, basePath);
        },
        /**
         * Post user actions on feed cards
         * @summary Post user interactions with feed
         * @param {Array<Card>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFeed(body, userId, clientId, options) {
            return exports.FeedApiFp(configuration).postFeed(body, userId, clientId, options)(fetch, basePath);
        },
    };
};
/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
class FeedApi extends BaseAPI {
    /**
     * Tracking reminder notifications, messages, and study results
     * @summary Tracking reminder notifications, messages, and study results
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options) {
        return exports.FeedApiFp(this.configuration).getFeed(sort, userId, createdAt, updatedAt, limit, offset, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post user actions on feed cards
     * @summary Post user interactions with feed
     * @param {Array<Card>} body Id of the tracking reminder notification to be snoozed
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    postFeed(body, userId, clientId, options) {
        return exports.FeedApiFp(this.configuration).postFeed(body, userId, clientId, options)(this.fetch, this.basePath);
    }
}
exports.FeedApi = FeedApi;
/**
 * FriendsApi - fetch parameter creator
 * @export
 */
exports.FriendsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get Friends
         * @summary Get Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/friends`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post Friends
         * @summary Post Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/friends`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FriendsApi - functional programming interface
 * @export
 */
exports.FriendsApiFp = function (configuration) {
    return {
        /**
         * Get Friends
         * @summary Get Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.FriendsApiFetchParamCreator(configuration).getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post Friends
         * @summary Post Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.FriendsApiFetchParamCreator(configuration).postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * FriendsApi - factory interface
 * @export
 */
exports.FriendsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get Friends
         * @summary Get Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.FriendsApiFp(configuration).getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post Friends
         * @summary Post Friends
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.FriendsApiFp(configuration).postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};
/**
 * FriendsApi - object-oriented interface
 * @export
 * @class FriendsApi
 * @extends {BaseAPI}
 */
class FriendsApi extends BaseAPI {
    /**
     * Get Friends
     * @summary Get Friends
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.FriendsApiFp(this.configuration).getFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post Friends
     * @summary Post Friends
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FriendsApi
     */
    postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.FriendsApiFp(this.configuration).postFriends(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
}
exports.FriendsApi = FriendsApi;
/**
 * GroupsApi - fetch parameter creator
 * @export
 */
exports.GroupsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get Groups
         * @summary Get Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get GroupsMembers
         * @summary Get GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/groupsMembers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post Groups
         * @summary Post Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/groups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post GroupsMembers
         * @summary Post GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/groupsMembers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * GroupsApi - functional programming interface
 * @export
 */
exports.GroupsApiFp = function (configuration) {
    return {
        /**
         * Get Groups
         * @summary Get Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.GroupsApiFetchParamCreator(configuration).getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get GroupsMembers
         * @summary Get GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.GroupsApiFetchParamCreator(configuration).getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post Groups
         * @summary Post Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.GroupsApiFetchParamCreator(configuration).postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post GroupsMembers
         * @summary Post GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.GroupsApiFetchParamCreator(configuration).postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * GroupsApi - factory interface
 * @export
 */
exports.GroupsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get Groups
         * @summary Get Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.GroupsApiFp(configuration).getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get GroupsMembers
         * @summary Get GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.GroupsApiFp(configuration).getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post Groups
         * @summary Post Groups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.GroupsApiFp(configuration).postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post GroupsMembers
         * @summary Post GroupsMembers
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.GroupsApiFp(configuration).postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
class GroupsApi extends BaseAPI {
    /**
     * Get Groups
     * @summary Get Groups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.GroupsApiFp(this.configuration).getGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Get GroupsMembers
     * @summary Get GroupsMembers
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.GroupsApiFp(this.configuration).getGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post Groups
     * @summary Post Groups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.GroupsApiFp(this.configuration).postGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post GroupsMembers
     * @summary Post GroupsMembers
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.GroupsApiFp(this.configuration).postGroupsMembers(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
}
exports.GroupsApi = GroupsApi;
/**
 * MeasurementsApi - fetch parameter creator
 * @export
 */
exports.MeasurementsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Delete a previously submitted measurement
         * @summary Delete a measurement
         * @param {MeasurementDelete} body The startTime and variableId of the measurement to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeasurement(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling deleteMeasurement.');
            }
            const localVarPath = `/v3/measurements/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("MeasurementDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
         * @summary Get measurements for this user
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [connectorName] Ex: facebook
         * @param {string} [value] Value of measurement
         * @param {string} [unitName] Options: % Recommended Daily Allowance, -4 to 4 Rating, 0 to 1 Rating, 0 to 5 Rating, 1 to 10 Rating, 1 to 5 Rating, Applications, Beats per Minute, Calories, Capsules, Centimeters, Count, Degrees Celsius, Degrees East, Degrees Fahrenheit, Degrees North, Dollars, Drops, Event, Feet, Grams, Hours, Inches, Index, Kilocalories, Kilograms, Kilometers, Liters, Meters, Micrograms, Micrograms per decilitre, Miles, Milligrams, Milliliters, Millimeters, Millimeters Merc, Milliseconds, Minutes, Pascal, Percent, Pieces, Pills, Pounds, Puffs, Seconds, Serving, Sprays, Tablets, Torr, Units, Yes/No, per Minute, Doses, Quarts, Ounces, International Units, Meters per Second
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Measurement id
         * @param {number} [groupingWidth] The time (in seconds) over which measurements are grouped together
         * @param {string} [groupingTimezone] The time (in seconds) over which measurements are grouped together
         * @param {boolean} [doNotProcess] Ex: true
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [doNotConvert] Ex: 1
         * @param {boolean} [minMaxFilter] Ex: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options = {}) {
            const localVarPath = `/v3/measurements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (variableName !== undefined) {
                localVarQueryParameter['variableName'] = variableName;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }
            if (connectorName !== undefined) {
                localVarQueryParameter['connectorName'] = connectorName;
            }
            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }
            if (unitName !== undefined) {
                localVarQueryParameter['unitName'] = unitName;
            }
            if (earliestMeasurementTime !== undefined) {
                localVarQueryParameter['earliestMeasurementTime'] = earliestMeasurementTime;
            }
            if (latestMeasurementTime !== undefined) {
                localVarQueryParameter['latestMeasurementTime'] = latestMeasurementTime;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (groupingWidth !== undefined) {
                localVarQueryParameter['groupingWidth'] = groupingWidth;
            }
            if (groupingTimezone !== undefined) {
                localVarQueryParameter['groupingTimezone'] = groupingTimezone;
            }
            if (doNotProcess !== undefined) {
                localVarQueryParameter['doNotProcess'] = doNotProcess;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (doNotConvert !== undefined) {
                localVarQueryParameter['doNotConvert'] = doNotConvert;
            }
            if (minMaxFilter !== undefined) {
                localVarQueryParameter['minMaxFilter'] = minMaxFilter;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
         * @summary Get pairs of measurements for correlational analysis
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [effectUnitName] Name for the unit effect measurements to be returned in
         * @param {number} [userId] User&#39;s id
         * @param {string} [causeUnitName] Name for the unit cause measurements to be returned in
         * @param {string} [onsetDelay] The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
         * @param {string} [durationOfAction] The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options = {}) {
            const localVarPath = `/v3/pairs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            if (effectUnitName !== undefined) {
                localVarQueryParameter['effectUnitName'] = effectUnitName;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (causeUnitName !== undefined) {
                localVarQueryParameter['causeUnitName'] = causeUnitName;
            }
            if (onsetDelay !== undefined) {
                localVarQueryParameter['onsetDelay'] = onsetDelay;
            }
            if (durationOfAction !== undefined) {
                localVarQueryParameter['durationOfAction'] = durationOfAction;
            }
            if (earliestMeasurementTime !== undefined) {
                localVarQueryParameter['earliestMeasurementTime'] = earliestMeasurementTime;
            }
            if (latestMeasurementTime !== undefined) {
                localVarQueryParameter['latestMeasurementTime'] = latestMeasurementTime;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
         * @summary Post Request for Measurements CSV
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementExportRequest(userId, options = {}) {
            const localVarPath = `/v2/measurements/exportRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
         * @summary Post a new set or update existing measurements to the database
         * @param {Array<MeasurementSet>} body An array of measurement sets containing measurement items you want to insert.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMeasurements(body, userId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postMeasurements.');
            }
            const localVarPath = `/v3/measurements/post`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;MeasurementSet&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a previously submitted measurement
         * @summary Update a measurement
         * @param {MeasurementUpdate} body The id as well as the new startTime, note, and/or value of the measurement to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeasurement(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateMeasurement.');
            }
            const localVarPath = `/v3/measurements/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("MeasurementUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MeasurementsApi - functional programming interface
 * @export
 */
exports.MeasurementsApiFp = function (configuration) {
    return {
        /**
         * Delete a previously submitted measurement
         * @summary Delete a measurement
         * @param {MeasurementDelete} body The startTime and variableId of the measurement to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeasurement(body, options) {
            const localVarFetchArgs = exports.MeasurementsApiFetchParamCreator(configuration).deleteMeasurement(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
         * @summary Get measurements for this user
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [connectorName] Ex: facebook
         * @param {string} [value] Value of measurement
         * @param {string} [unitName] Options: % Recommended Daily Allowance, -4 to 4 Rating, 0 to 1 Rating, 0 to 5 Rating, 1 to 10 Rating, 1 to 5 Rating, Applications, Beats per Minute, Calories, Capsules, Centimeters, Count, Degrees Celsius, Degrees East, Degrees Fahrenheit, Degrees North, Dollars, Drops, Event, Feet, Grams, Hours, Inches, Index, Kilocalories, Kilograms, Kilometers, Liters, Meters, Micrograms, Micrograms per decilitre, Miles, Milligrams, Milliliters, Millimeters, Millimeters Merc, Milliseconds, Minutes, Pascal, Percent, Pieces, Pills, Pounds, Puffs, Seconds, Serving, Sprays, Tablets, Torr, Units, Yes/No, per Minute, Doses, Quarts, Ounces, International Units, Meters per Second
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Measurement id
         * @param {number} [groupingWidth] The time (in seconds) over which measurements are grouped together
         * @param {string} [groupingTimezone] The time (in seconds) over which measurements are grouped together
         * @param {boolean} [doNotProcess] Ex: true
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [doNotConvert] Ex: 1
         * @param {boolean} [minMaxFilter] Ex: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options) {
            const localVarFetchArgs = exports.MeasurementsApiFetchParamCreator(configuration).getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
         * @summary Get pairs of measurements for correlational analysis
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [effectUnitName] Name for the unit effect measurements to be returned in
         * @param {number} [userId] User&#39;s id
         * @param {string} [causeUnitName] Name for the unit cause measurements to be returned in
         * @param {string} [onsetDelay] The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
         * @param {string} [durationOfAction] The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options) {
            const localVarFetchArgs = exports.MeasurementsApiFetchParamCreator(configuration).getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
         * @summary Post Request for Measurements CSV
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementExportRequest(userId, options) {
            const localVarFetchArgs = exports.MeasurementsApiFetchParamCreator(configuration).measurementExportRequest(userId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
         * @summary Post a new set or update existing measurements to the database
         * @param {Array<MeasurementSet>} body An array of measurement sets containing measurement items you want to insert.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMeasurements(body, userId, options) {
            const localVarFetchArgs = exports.MeasurementsApiFetchParamCreator(configuration).postMeasurements(body, userId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a previously submitted measurement
         * @summary Update a measurement
         * @param {MeasurementUpdate} body The id as well as the new startTime, note, and/or value of the measurement to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeasurement(body, options) {
            const localVarFetchArgs = exports.MeasurementsApiFetchParamCreator(configuration).updateMeasurement(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * MeasurementsApi - factory interface
 * @export
 */
exports.MeasurementsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Delete a previously submitted measurement
         * @summary Delete a measurement
         * @param {MeasurementDelete} body The startTime and variableId of the measurement to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMeasurement(body, options) {
            return exports.MeasurementsApiFp(configuration).deleteMeasurement(body, options)(fetch, basePath);
        },
        /**
         * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
         * @summary Get measurements for this user
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [connectorName] Ex: facebook
         * @param {string} [value] Value of measurement
         * @param {string} [unitName] Options: % Recommended Daily Allowance, -4 to 4 Rating, 0 to 1 Rating, 0 to 5 Rating, 1 to 10 Rating, 1 to 5 Rating, Applications, Beats per Minute, Calories, Capsules, Centimeters, Count, Degrees Celsius, Degrees East, Degrees Fahrenheit, Degrees North, Dollars, Drops, Event, Feet, Grams, Hours, Inches, Index, Kilocalories, Kilograms, Kilometers, Liters, Meters, Micrograms, Micrograms per decilitre, Miles, Milligrams, Milliliters, Millimeters, Millimeters Merc, Milliseconds, Minutes, Pascal, Percent, Pieces, Pills, Pounds, Puffs, Seconds, Serving, Sprays, Tablets, Torr, Units, Yes/No, per Minute, Doses, Quarts, Ounces, International Units, Meters per Second
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Measurement id
         * @param {number} [groupingWidth] The time (in seconds) over which measurements are grouped together
         * @param {string} [groupingTimezone] The time (in seconds) over which measurements are grouped together
         * @param {boolean} [doNotProcess] Ex: true
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [doNotConvert] Ex: 1
         * @param {boolean} [minMaxFilter] Ex: 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options) {
            return exports.MeasurementsApiFp(configuration).getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options)(fetch, basePath);
        },
        /**
         * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
         * @summary Get pairs of measurements for correlational analysis
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [effectUnitName] Name for the unit effect measurements to be returned in
         * @param {number} [userId] User&#39;s id
         * @param {string} [causeUnitName] Name for the unit cause measurements to be returned in
         * @param {string} [onsetDelay] The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
         * @param {string} [durationOfAction] The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options) {
            return exports.MeasurementsApiFp(configuration).getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options)(fetch, basePath);
        },
        /**
         * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
         * @summary Post Request for Measurements CSV
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        measurementExportRequest(userId, options) {
            return exports.MeasurementsApiFp(configuration).measurementExportRequest(userId, options)(fetch, basePath);
        },
        /**
         * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
         * @summary Post a new set or update existing measurements to the database
         * @param {Array<MeasurementSet>} body An array of measurement sets containing measurement items you want to insert.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMeasurements(body, userId, options) {
            return exports.MeasurementsApiFp(configuration).postMeasurements(body, userId, options)(fetch, basePath);
        },
        /**
         * Update a previously submitted measurement
         * @summary Update a measurement
         * @param {MeasurementUpdate} body The id as well as the new startTime, note, and/or value of the measurement to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMeasurement(body, options) {
            return exports.MeasurementsApiFp(configuration).updateMeasurement(body, options)(fetch, basePath);
        },
    };
};
/**
 * MeasurementsApi - object-oriented interface
 * @export
 * @class MeasurementsApi
 * @extends {BaseAPI}
 */
class MeasurementsApi extends BaseAPI {
    /**
     * Delete a previously submitted measurement
     * @summary Delete a measurement
     * @param {MeasurementDelete} body The startTime and variableId of the measurement to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    deleteMeasurement(body, options) {
        return exports.MeasurementsApiFp(this.configuration).deleteMeasurement(body, options)(this.fetch, this.basePath);
    }
    /**
     * Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten.
     * @summary Get measurements for this user
     * @param {string} [variableName] Name of the variable you want measurements for
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
     * @param {string} [connectorName] Ex: facebook
     * @param {string} [value] Value of measurement
     * @param {string} [unitName] Options: % Recommended Daily Allowance, -4 to 4 Rating, 0 to 1 Rating, 0 to 5 Rating, 1 to 10 Rating, 1 to 5 Rating, Applications, Beats per Minute, Calories, Capsules, Centimeters, Count, Degrees Celsius, Degrees East, Degrees Fahrenheit, Degrees North, Dollars, Drops, Event, Feet, Grams, Hours, Inches, Index, Kilocalories, Kilograms, Kilometers, Liters, Meters, Micrograms, Micrograms per decilitre, Miles, Milligrams, Milliliters, Millimeters, Millimeters Merc, Milliseconds, Minutes, Pascal, Percent, Pieces, Pills, Pounds, Puffs, Seconds, Serving, Sprays, Tablets, Torr, Units, Yes/No, per Minute, Doses, Quarts, Ounces, International Units, Meters per Second
     * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Measurement id
     * @param {number} [groupingWidth] The time (in seconds) over which measurements are grouped together
     * @param {string} [groupingTimezone] The time (in seconds) over which measurements are grouped together
     * @param {boolean} [doNotProcess] Ex: true
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [doNotConvert] Ex: 1
     * @param {boolean} [minMaxFilter] Ex: 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options) {
        return exports.MeasurementsApiFp(this.configuration).getMeasurements(variableName, sort, limit, offset, variableCategoryName, updatedAt, userId, sourceName, connectorName, value, unitName, earliestMeasurementTime, latestMeasurementTime, createdAt, id, groupingWidth, groupingTimezone, doNotProcess, clientId, doNotConvert, minMaxFilter, options)(this.fetch, this.basePath);
    }
    /**
     * Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.
     * @summary Get pairs of measurements for correlational analysis
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [effectUnitName] Name for the unit effect measurements to be returned in
     * @param {number} [userId] User&#39;s id
     * @param {string} [causeUnitName] Name for the unit cause measurements to be returned in
     * @param {string} [onsetDelay] The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the onset delay. For example, the onset delay between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.
     * @param {string} [durationOfAction] The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay. Unit: Seconds
     * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options) {
        return exports.MeasurementsApiFp(this.configuration).getPairs(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, effectUnitName, userId, causeUnitName, onsetDelay, durationOfAction, earliestMeasurementTime, latestMeasurementTime, limit, offset, sort, options)(this.fetch, this.basePath);
    }
    /**
     * Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.
     * @summary Post Request for Measurements CSV
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    measurementExportRequest(userId, options) {
        return exports.MeasurementsApiFp(this.configuration).measurementExportRequest(userId, options)(this.fetch, this.basePath);
    }
    /**
     * You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.
     * @summary Post a new set or update existing measurements to the database
     * @param {Array<MeasurementSet>} body An array of measurement sets containing measurement items you want to insert.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    postMeasurements(body, userId, options) {
        return exports.MeasurementsApiFp(this.configuration).postMeasurements(body, userId, options)(this.fetch, this.basePath);
    }
    /**
     * Update a previously submitted measurement
     * @summary Update a measurement
     * @param {MeasurementUpdate} body The id as well as the new startTime, note, and/or value of the measurement to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeasurementsApi
     */
    updateMeasurement(body, options) {
        return exports.MeasurementsApiFp(this.configuration).updateMeasurement(body, options)(this.fetch, this.basePath);
    }
}
exports.MeasurementsApi = MeasurementsApi;
/**
 * MessagesApi - fetch parameter creator
 * @export
 */
exports.MessagesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get MessagesMessages
         * @summary Get MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/messagesMessages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MessagesNotices
         * @summary Get MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/messagesNotices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MessagesRecipients
         * @summary Get MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/messagesRecipients`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post MessagesMessages
         * @summary Post MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/messagesMessages`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post MessagesNotices
         * @summary Post MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/messagesNotices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post MessagesRecipients
         * @summary Post MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/messagesRecipients`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessagesApi - functional programming interface
 * @export
 */
exports.MessagesApiFp = function (configuration) {
    return {
        /**
         * Get MessagesMessages
         * @summary Get MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.MessagesApiFetchParamCreator(configuration).getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get MessagesNotices
         * @summary Get MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.MessagesApiFetchParamCreator(configuration).getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get MessagesRecipients
         * @summary Get MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.MessagesApiFetchParamCreator(configuration).getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post MessagesMessages
         * @summary Post MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.MessagesApiFetchParamCreator(configuration).postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post MessagesNotices
         * @summary Post MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.MessagesApiFetchParamCreator(configuration).postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post MessagesRecipients
         * @summary Post MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.MessagesApiFetchParamCreator(configuration).postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * MessagesApi - factory interface
 * @export
 */
exports.MessagesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get MessagesMessages
         * @summary Get MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.MessagesApiFp(configuration).getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get MessagesNotices
         * @summary Get MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.MessagesApiFp(configuration).getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get MessagesRecipients
         * @summary Get MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.MessagesApiFp(configuration).getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post MessagesMessages
         * @summary Post MessagesMessages
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.MessagesApiFp(configuration).postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post MessagesNotices
         * @summary Post MessagesNotices
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.MessagesApiFp(configuration).postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post MessagesRecipients
         * @summary Post MessagesRecipients
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.MessagesApiFp(configuration).postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};
/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
class MessagesApi extends BaseAPI {
    /**
     * Get MessagesMessages
     * @summary Get MessagesMessages
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.MessagesApiFp(this.configuration).getMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Get MessagesNotices
     * @summary Get MessagesNotices
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.MessagesApiFp(this.configuration).getMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Get MessagesRecipients
     * @summary Get MessagesRecipients
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.MessagesApiFp(this.configuration).getMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post MessagesMessages
     * @summary Post MessagesMessages
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.MessagesApiFp(this.configuration).postMessagesMessages(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post MessagesNotices
     * @summary Post MessagesNotices
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.MessagesApiFp(this.configuration).postMessagesNotices(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post MessagesRecipients
     * @summary Post MessagesRecipients
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.MessagesApiFp(this.configuration).postMessagesRecipients(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
}
exports.MessagesApi = MessagesApi;
/**
 * NotificationsApi - fetch parameter creator
 * @export
 */
exports.NotificationsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get NotificationPreferences
         * @summary Get NotificationPreferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationPreferences(options = {}) {
            const localVarPath = `/v3/notificationPreferences`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Notifications
         * @summary Get Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post user token for Android, iOS, or web push notifications
         * @summary Post DeviceTokens
         * @param {DeviceToken} body The platform and token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeviceToken(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postDeviceToken.');
            }
            const localVarPath = `/v3/deviceTokens`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("DeviceToken" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post Notifications
         * @summary Post Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/notifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NotificationsApi - functional programming interface
 * @export
 */
exports.NotificationsApiFp = function (configuration) {
    return {
        /**
         * Get NotificationPreferences
         * @summary Get NotificationPreferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationPreferences(options) {
            const localVarFetchArgs = exports.NotificationsApiFetchParamCreator(configuration).getNotificationPreferences(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Notifications
         * @summary Get Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.NotificationsApiFetchParamCreator(configuration).getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post user token for Android, iOS, or web push notifications
         * @summary Post DeviceTokens
         * @param {DeviceToken} body The platform and token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeviceToken(body, options) {
            const localVarFetchArgs = exports.NotificationsApiFetchParamCreator(configuration).postDeviceToken(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post Notifications
         * @summary Post Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.NotificationsApiFetchParamCreator(configuration).postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * NotificationsApi - factory interface
 * @export
 */
exports.NotificationsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get NotificationPreferences
         * @summary Get NotificationPreferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotificationPreferences(options) {
            return exports.NotificationsApiFp(configuration).getNotificationPreferences(options)(fetch, basePath);
        },
        /**
         * Get Notifications
         * @summary Get Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.NotificationsApiFp(configuration).getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post user token for Android, iOS, or web push notifications
         * @summary Post DeviceTokens
         * @param {DeviceToken} body The platform and token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDeviceToken(body, options) {
            return exports.NotificationsApiFp(configuration).postDeviceToken(body, options)(fetch, basePath);
        },
        /**
         * Post Notifications
         * @summary Post Notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.NotificationsApiFp(configuration).postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};
/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
class NotificationsApi extends BaseAPI {
    /**
     * Get NotificationPreferences
     * @summary Get NotificationPreferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    getNotificationPreferences(options) {
        return exports.NotificationsApiFp(this.configuration).getNotificationPreferences(options)(this.fetch, this.basePath);
    }
    /**
     * Get Notifications
     * @summary Get Notifications
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.NotificationsApiFp(this.configuration).getNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post user token for Android, iOS, or web push notifications
     * @summary Post DeviceTokens
     * @param {DeviceToken} body The platform and token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    postDeviceToken(body, options) {
        return exports.NotificationsApiFp(this.configuration).postDeviceToken(body, options)(this.fetch, this.basePath);
    }
    /**
     * Post Notifications
     * @summary Post Notifications
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.NotificationsApiFp(this.configuration).postNotifications(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
}
exports.NotificationsApi = NotificationsApi;
/**
 * RemindersApi - fetch parameter creator
 * @export
 */
exports.RemindersApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
         * @summary Delete Tracking Reminder
         * @param {TrackingReminderDelete} body Id of reminder to be deleted
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackingReminder(body, userId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling deleteTrackingReminder.');
            }
            const localVarPath = `/v3/trackingReminders/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("TrackingReminderDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Specific tracking reminder notification instances that still need to be tracked.
         * @summary Get specific tracking reminder notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [reminderTime] Ex: (lt)2017-07-31 21:43:26
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [onlyPast] Ex: 1
         * @param {boolean} [includeDeleted] Include deleted variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options = {}) {
            const localVarPath = `/v3/trackingReminderNotifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }
            if (reminderTime !== undefined) {
                localVarQueryParameter['reminderTime'] = reminderTime;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (onlyPast !== undefined) {
                localVarQueryParameter['onlyPast'] = onlyPast;
            }
            if (includeDeleted !== undefined) {
                localVarQueryParameter['includeDeleted'] = includeDeleted;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can be reminded to track certain variables at a specified frequency with a default value.
         * @summary Get repeating tracking reminder settings
         * @param {number} [userId] User&#39;s id
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options = {}) {
            const localVarPath = `/v3/trackingReminders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Snooze, skip, or track a tracking reminder notification
         * @summary Snooze, skip, or track a tracking reminder notification
         * @param {Array<TrackingReminderNotificationPost>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminderNotifications(body, userId, clientId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postTrackingReminderNotifications.');
            }
            const localVarPath = `/v3/trackingReminderNotifications`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;TrackingReminderNotificationPost&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is to enable users to create reminders to track a variable with a default value at a specified frequency
         * @summary Store a Tracking Reminder
         * @param {Array<TrackingReminder>} body TrackingReminder that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminders(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postTrackingReminders.');
            }
            const localVarPath = `/v3/trackingReminders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;TrackingReminder&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * RemindersApi - functional programming interface
 * @export
 */
exports.RemindersApiFp = function (configuration) {
    return {
        /**
         * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
         * @summary Delete Tracking Reminder
         * @param {TrackingReminderDelete} body Id of reminder to be deleted
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackingReminder(body, userId, options) {
            const localVarFetchArgs = exports.RemindersApiFetchParamCreator(configuration).deleteTrackingReminder(body, userId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Specific tracking reminder notification instances that still need to be tracked.
         * @summary Get specific tracking reminder notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [reminderTime] Ex: (lt)2017-07-31 21:43:26
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [onlyPast] Ex: 1
         * @param {boolean} [includeDeleted] Include deleted variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options) {
            const localVarFetchArgs = exports.RemindersApiFetchParamCreator(configuration).getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Users can be reminded to track certain variables at a specified frequency with a default value.
         * @summary Get repeating tracking reminder settings
         * @param {number} [userId] User&#39;s id
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options) {
            const localVarFetchArgs = exports.RemindersApiFetchParamCreator(configuration).getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Snooze, skip, or track a tracking reminder notification
         * @summary Snooze, skip, or track a tracking reminder notification
         * @param {Array<TrackingReminderNotificationPost>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminderNotifications(body, userId, clientId, options) {
            const localVarFetchArgs = exports.RemindersApiFetchParamCreator(configuration).postTrackingReminderNotifications(body, userId, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This is to enable users to create reminders to track a variable with a default value at a specified frequency
         * @summary Store a Tracking Reminder
         * @param {Array<TrackingReminder>} body TrackingReminder that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminders(body, options) {
            const localVarFetchArgs = exports.RemindersApiFetchParamCreator(configuration).postTrackingReminders(body, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * RemindersApi - factory interface
 * @export
 */
exports.RemindersApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
         * @summary Delete Tracking Reminder
         * @param {TrackingReminderDelete} body Id of reminder to be deleted
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTrackingReminder(body, userId, options) {
            return exports.RemindersApiFp(configuration).deleteTrackingReminder(body, userId, options)(fetch, basePath);
        },
        /**
         * Specific tracking reminder notification instances that still need to be tracked.
         * @summary Get specific tracking reminder notifications
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [reminderTime] Ex: (lt)2017-07-31 21:43:26
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [onlyPast] Ex: 1
         * @param {boolean} [includeDeleted] Include deleted variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options) {
            return exports.RemindersApiFp(configuration).getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options)(fetch, basePath);
        },
        /**
         * Users can be reminded to track certain variables at a specified frequency with a default value.
         * @summary Get repeating tracking reminder settings
         * @param {number} [userId] User&#39;s id
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options) {
            return exports.RemindersApiFp(configuration).getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options)(fetch, basePath);
        },
        /**
         * Snooze, skip, or track a tracking reminder notification
         * @summary Snooze, skip, or track a tracking reminder notification
         * @param {Array<TrackingReminderNotificationPost>} body Id of the tracking reminder notification to be snoozed
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminderNotifications(body, userId, clientId, options) {
            return exports.RemindersApiFp(configuration).postTrackingReminderNotifications(body, userId, clientId, options)(fetch, basePath);
        },
        /**
         * This is to enable users to create reminders to track a variable with a default value at a specified frequency
         * @summary Store a Tracking Reminder
         * @param {Array<TrackingReminder>} body TrackingReminder that should be stored
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrackingReminders(body, options) {
            return exports.RemindersApiFp(configuration).postTrackingReminders(body, options)(fetch, basePath);
        },
    };
};
/**
 * RemindersApi - object-oriented interface
 * @export
 * @class RemindersApi
 * @extends {BaseAPI}
 */
class RemindersApi extends BaseAPI {
    /**
     * Stop getting notifications to record data for a variable.  Previously recorded measurements will be preserved.
     * @summary Delete Tracking Reminder
     * @param {TrackingReminderDelete} body Id of reminder to be deleted
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    deleteTrackingReminder(body, userId, options) {
        return exports.RemindersApiFp(this.configuration).deleteTrackingReminder(body, userId, options)(this.fetch, this.basePath);
    }
    /**
     * Specific tracking reminder notification instances that still need to be tracked.
     * @summary Get specific tracking reminder notifications
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param {string} [reminderTime] Ex: (lt)2017-07-31 21:43:26
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [onlyPast] Ex: 1
     * @param {boolean} [includeDeleted] Include deleted variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options) {
        return exports.RemindersApiFp(this.configuration).getTrackingReminderNotifications(sort, userId, createdAt, updatedAt, limit, offset, variableCategoryName, reminderTime, clientId, onlyPast, includeDeleted, options)(this.fetch, this.basePath);
    }
    /**
     * Users can be reminded to track certain variables at a specified frequency with a default value.
     * @summary Get repeating tracking reminder settings
     * @param {number} [userId] User&#39;s id
     * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options) {
        return exports.RemindersApiFp(this.configuration).getTrackingReminders(userId, variableCategoryName, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, options)(this.fetch, this.basePath);
    }
    /**
     * Snooze, skip, or track a tracking reminder notification
     * @summary Snooze, skip, or track a tracking reminder notification
     * @param {Array<TrackingReminderNotificationPost>} body Id of the tracking reminder notification to be snoozed
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    postTrackingReminderNotifications(body, userId, clientId, options) {
        return exports.RemindersApiFp(this.configuration).postTrackingReminderNotifications(body, userId, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * This is to enable users to create reminders to track a variable with a default value at a specified frequency
     * @summary Store a Tracking Reminder
     * @param {Array<TrackingReminder>} body TrackingReminder that should be stored
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RemindersApi
     */
    postTrackingReminders(body, options) {
        return exports.RemindersApiFp(this.configuration).postTrackingReminders(body, options)(this.fetch, this.basePath);
    }
}
exports.RemindersApi = RemindersApi;
/**
 * SharesApi - fetch parameter creator
 * @export
 */
exports.SharesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Remove access to user data for a given client_id associated with a given individual, app, or study
         * @summary Delete share
         * @param {string} clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
         * @param {string} [reason] Ex: I hate you!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShare(clientIdToRevoke, reason, options = {}) {
            // verify required parameter 'clientIdToRevoke' is not null or undefined
            if (clientIdToRevoke === null || clientIdToRevoke === undefined) {
                throw new RequiredError('clientIdToRevoke', 'Required parameter clientIdToRevoke was null or undefined when calling deleteShare.');
            }
            const localVarPath = `/v3/shares/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (clientIdToRevoke !== undefined) {
                localVarQueryParameter['clientIdToRevoke'] = clientIdToRevoke;
            }
            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a list of individuals, apps, or studies with access to your measurements.
         * @summary Get Authorized Apps, Studies, and Individuals
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options = {}) {
            const localVarPath = `/v3/shares`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }
            if (log !== undefined) {
                localVarQueryParameter['log'] = log;
            }
            if (pwd !== undefined) {
                localVarQueryParameter['pwd'] = pwd;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invite someone to view your measurements
         * @summary Delete share
         * @param {ShareInvitationBody} body Details about person to share with
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteShare(body, clientId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling inviteShare.');
            }
            const localVarPath = `/v3/shares/invite`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("ShareInvitationBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SharesApi - functional programming interface
 * @export
 */
exports.SharesApiFp = function (configuration) {
    return {
        /**
         * Remove access to user data for a given client_id associated with a given individual, app, or study
         * @summary Delete share
         * @param {string} clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
         * @param {string} [reason] Ex: I hate you!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShare(clientIdToRevoke, reason, options) {
            const localVarFetchArgs = exports.SharesApiFetchParamCreator(configuration).deleteShare(clientIdToRevoke, reason, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This is a list of individuals, apps, or studies with access to your measurements.
         * @summary Get Authorized Apps, Studies, and Individuals
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options) {
            const localVarFetchArgs = exports.SharesApiFetchParamCreator(configuration).getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Invite someone to view your measurements
         * @summary Delete share
         * @param {ShareInvitationBody} body Details about person to share with
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteShare(body, clientId, options) {
            const localVarFetchArgs = exports.SharesApiFetchParamCreator(configuration).inviteShare(body, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * SharesApi - factory interface
 * @export
 */
exports.SharesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Remove access to user data for a given client_id associated with a given individual, app, or study
         * @summary Delete share
         * @param {string} clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
         * @param {string} [reason] Ex: I hate you!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShare(clientIdToRevoke, reason, options) {
            return exports.SharesApiFp(configuration).deleteShare(clientIdToRevoke, reason, options)(fetch, basePath);
        },
        /**
         * This is a list of individuals, apps, or studies with access to your measurements.
         * @summary Get Authorized Apps, Studies, and Individuals
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options) {
            return exports.SharesApiFp(configuration).getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options)(fetch, basePath);
        },
        /**
         * Invite someone to view your measurements
         * @summary Delete share
         * @param {ShareInvitationBody} body Details about person to share with
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteShare(body, clientId, options) {
            return exports.SharesApiFp(configuration).inviteShare(body, clientId, options)(fetch, basePath);
        },
    };
};
/**
 * SharesApi - object-oriented interface
 * @export
 * @class SharesApi
 * @extends {BaseAPI}
 */
class SharesApi extends BaseAPI {
    /**
     * Remove access to user data for a given client_id associated with a given individual, app, or study
     * @summary Delete share
     * @param {string} clientIdToRevoke Client id of the individual, study, or app that the user wishes to no longer have access to their data
     * @param {string} [reason] Ex: I hate you!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    deleteShare(clientIdToRevoke, reason, options) {
        return exports.SharesApiFp(this.configuration).deleteShare(clientIdToRevoke, reason, options)(this.fetch, this.basePath);
    }
    /**
     * This is a list of individuals, apps, or studies with access to your measurements.
     * @summary Get Authorized Apps, Studies, and Individuals
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {string} [log] Username or email
     * @param {string} [pwd] User password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options) {
        return exports.SharesApiFp(this.configuration).getShares(userId, createdAt, updatedAt, clientId, appVersion, log, pwd, options)(this.fetch, this.basePath);
    }
    /**
     * Invite someone to view your measurements
     * @summary Delete share
     * @param {ShareInvitationBody} body Details about person to share with
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SharesApi
     */
    inviteShare(body, clientId, options) {
        return exports.SharesApiFp(this.configuration).inviteShare(body, clientId, options)(this.fetch, this.basePath);
    }
}
exports.SharesApi = SharesApi;
/**
 * StudiesApi - fetch parameter creator
 * @export
 */
exports.StudiesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
         * @summary Create a Study
         * @param {StudyCreationBody} body Details about the study you want to create
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudy(body, clientId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createStudy.');
            }
            const localVarPath = `/v3/study/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("StudyCreationBody" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete previously posted vote
         * @summary Delete vote
         * @param {VoteDelete} body The cause and effect variable names for the predictor vote to be deleted.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVote(body, userId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling deleteVote.');
            }
            const localVarPath = `/v3/votes/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("VoteDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
         * @summary These are open studies that anyone can join
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options = {}) {
            const localVarPath = `/v3/studies/open`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }
            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }
            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
         * @summary Get Personal or Population Studies
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {number} [principalInvestigatorUserId] These are studies created by a specific principal investigator
         * @param {boolean} [open] These are studies that anyone can join
         * @param {boolean} [joined] These are studies that you have joined
         * @param {boolean} [created] These are studies that you have created
         * @param {boolean} [population] These are studies based on the entire population of users that have shared their data
         * @param {boolean} [downvoted] These are studies that you have down-voted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options = {}) {
            const localVarPath = `/v3/studies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }
            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }
            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (correlationCoefficient !== undefined) {
                localVarQueryParameter['correlationCoefficient'] = correlationCoefficient;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (outcomesOfInterest !== undefined) {
                localVarQueryParameter['outcomesOfInterest'] = outcomesOfInterest;
            }
            if (principalInvestigatorUserId !== undefined) {
                localVarQueryParameter['principalInvestigatorUserId'] = principalInvestigatorUserId;
            }
            if (open !== undefined) {
                localVarQueryParameter['open'] = open;
            }
            if (joined !== undefined) {
                localVarQueryParameter['joined'] = joined;
            }
            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }
            if (population !== undefined) {
                localVarQueryParameter['population'] = population;
            }
            if (downvoted !== undefined) {
                localVarQueryParameter['downvoted'] = downvoted;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are studies that you have created.
         * @summary Get studies you have created
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options = {}) {
            const localVarPath = `/v3/studies/created`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * These are studies that you are currently sharing your data with.
         * @summary Studies You Have Joined
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options = {}) {
            const localVarPath = `/v3/studies/joined`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (correlationCoefficient !== undefined) {
                localVarQueryParameter['correlationCoefficient'] = correlationCoefficient;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (outcomesOfInterest !== undefined) {
                localVarQueryParameter['outcomesOfInterest'] = outcomesOfInterest;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Study
         * @summary Get Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options = {}) {
            const localVarPath = `/v4/study`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }
            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }
            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Anonymously share measurements for specified variables
         * @summary Join a Study
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options = {}) {
            const localVarPath = `/v3/study/join`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
         * @summary Post or update vote
         * @param {Vote} body Contains the cause variable, effect variable, and vote value.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVote(body, userId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postVote.');
            }
            const localVarPath = `/v3/votes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Vote" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Make a study and all related measurements publicly visible by anyone
         * @summary Publish Your Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options = {}) {
            const localVarPath = `/v3/study/publish`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (causeVariableName !== undefined) {
                localVarQueryParameter['causeVariableName'] = causeVariableName;
            }
            if (effectVariableName !== undefined) {
                localVarQueryParameter['effectVariableName'] = effectVariableName;
            }
            if (causeVariableId !== undefined) {
                localVarQueryParameter['causeVariableId'] = causeVariableId;
            }
            if (effectVariableId !== undefined) {
                localVarQueryParameter['effectVariableId'] = effectVariableId;
            }
            if (predictorVariableName !== undefined) {
                localVarQueryParameter['predictorVariableName'] = predictorVariableName;
            }
            if (outcomeVariableName !== undefined) {
                localVarQueryParameter['outcomeVariableName'] = outcomeVariableName;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }
            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }
            if (studyId !== undefined) {
                localVarQueryParameter['studyId'] = studyId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StudiesApi - functional programming interface
 * @export
 */
exports.StudiesApiFp = function (configuration) {
    return {
        /**
         * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
         * @summary Create a Study
         * @param {StudyCreationBody} body Details about the study you want to create
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudy(body, clientId, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).createStudy(body, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete previously posted vote
         * @summary Delete vote
         * @param {VoteDelete} body The cause and effect variable names for the predictor vote to be deleted.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVote(body, userId, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).deleteVote(body, userId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
         * @summary These are open studies that anyone can join
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
         * @summary Get Personal or Population Studies
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {number} [principalInvestigatorUserId] These are studies created by a specific principal investigator
         * @param {boolean} [open] These are studies that anyone can join
         * @param {boolean} [joined] These are studies that you have joined
         * @param {boolean} [created] These are studies that you have created
         * @param {boolean} [population] These are studies based on the entire population of users that have shared their data
         * @param {boolean} [downvoted] These are studies that you have down-voted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * These are studies that you have created.
         * @summary Get studies you have created
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * These are studies that you are currently sharing your data with.
         * @summary Studies You Have Joined
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Study
         * @summary Get Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Anonymously share measurements for specified variables
         * @summary Join a Study
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
         * @summary Post or update vote
         * @param {Vote} body Contains the cause variable, effect variable, and vote value.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVote(body, userId, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).postVote(body, userId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Make a study and all related measurements publicly visible by anyone
         * @summary Publish Your Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
            const localVarFetchArgs = exports.StudiesApiFetchParamCreator(configuration).publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * StudiesApi - factory interface
 * @export
 */
exports.StudiesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
         * @summary Create a Study
         * @param {StudyCreationBody} body Details about the study you want to create
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudy(body, clientId, options) {
            return exports.StudiesApiFp(configuration).createStudy(body, clientId, options)(fetch, basePath);
        },
        /**
         * Delete previously posted vote
         * @summary Delete vote
         * @param {VoteDelete} body The cause and effect variable names for the predictor vote to be deleted.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVote(body, userId, options) {
            return exports.StudiesApiFp(configuration).deleteVote(body, userId, options)(fetch, basePath);
        },
        /**
         * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
         * @summary These are open studies that anyone can join
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
            return exports.StudiesApiFp(configuration).getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(fetch, basePath);
        },
        /**
         * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
         * @summary Get Personal or Population Studies
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {number} [principalInvestigatorUserId] These are studies created by a specific principal investigator
         * @param {boolean} [open] These are studies that anyone can join
         * @param {boolean} [joined] These are studies that you have joined
         * @param {boolean} [created] These are studies that you have created
         * @param {boolean} [population] These are studies based on the entire population of users that have shared their data
         * @param {boolean} [downvoted] These are studies that you have down-voted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options) {
            return exports.StudiesApiFp(configuration).getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options)(fetch, basePath);
        },
        /**
         * These are studies that you have created.
         * @summary Get studies you have created
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options) {
            return exports.StudiesApiFp(configuration).getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options)(fetch, basePath);
        },
        /**
         * These are studies that you are currently sharing your data with.
         * @summary Studies You Have Joined
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {number} [userId] User&#39;s id
         * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options) {
            return exports.StudiesApiFp(configuration).getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options)(fetch, basePath);
        },
        /**
         * Get Study
         * @summary Get Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
            return exports.StudiesApiFp(configuration).getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(fetch, basePath);
        },
        /**
         * Anonymously share measurements for specified variables
         * @summary Join a Study
         * @param {string} [studyId] Client id for the study you want
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options) {
            return exports.StudiesApiFp(configuration).joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options)(fetch, basePath);
        },
        /**
         * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
         * @summary Post or update vote
         * @param {Vote} body Contains the cause variable, effect variable, and vote value.
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postVote(body, userId, options) {
            return exports.StudiesApiFp(configuration).postVote(body, userId, options)(fetch, basePath);
        },
        /**
         * Make a study and all related measurements publicly visible by anyone
         * @summary Publish Your Study
         * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
         * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
         * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
         * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
         * @param {number} [userId] User&#39;s id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {string} [studyId] Client id for the study you want
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
            return exports.StudiesApiFp(configuration).publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(fetch, basePath);
        },
    };
};
/**
 * StudiesApi - object-oriented interface
 * @export
 * @class StudiesApi
 * @extends {BaseAPI}
 */
class StudiesApi extends BaseAPI {
    /**
     * Create an individual, group, or population study examining the relationship between a predictor and outcome variable. You will be given a study id which you can invite participants to join and share their measurements for the specified variables.
     * @summary Create a Study
     * @param {StudyCreationBody} body Details about the study you want to create
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    createStudy(body, clientId, options) {
        return exports.StudiesApiFp(this.configuration).createStudy(body, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Delete previously posted vote
     * @summary Delete vote
     * @param {VoteDelete} body The cause and effect variable names for the predictor vote to be deleted.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    deleteVote(body, userId, options) {
        return exports.StudiesApiFp(this.configuration).deleteVote(body, userId, options)(this.fetch, this.basePath);
    }
    /**
     * These are studies that anyone can join and share their data for the predictor and outcome variables of interest.
     * @summary These are open studies that anyone can join
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
        return exports.StudiesApiFp(this.configuration).getOpenStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(this.fetch, this.basePath);
    }
    /**
     * If you have enough data, this will be a list of your personal studies, otherwise it will consist of aggregated population studies.
     * @summary Get Personal or Population Studies
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
     * @param {number} [principalInvestigatorUserId] These are studies created by a specific principal investigator
     * @param {boolean} [open] These are studies that anyone can join
     * @param {boolean} [joined] These are studies that you have joined
     * @param {boolean} [created] These are studies that you have created
     * @param {boolean} [population] These are studies based on the entire population of users that have shared their data
     * @param {boolean} [downvoted] These are studies that you have down-voted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options) {
        return exports.StudiesApiFp(this.configuration).getStudies(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, sort, limit, offset, correlationCoefficient, updatedAt, outcomesOfInterest, principalInvestigatorUserId, open, joined, created, population, downvoted, options)(this.fetch, this.basePath);
    }
    /**
     * These are studies that you have created.
     * @summary Get studies you have created
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {number} [userId] User&#39;s id
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options) {
        return exports.StudiesApiFp(this.configuration).getStudiesCreated(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, updatedAt, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * These are studies that you are currently sharing your data with.
     * @summary Studies You Have Joined
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {number} [userId] User&#39;s id
     * @param {string} [correlationCoefficient] Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {boolean} [outcomesOfInterest] Only include correlations for which the effect is an outcome of interest for the user
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options) {
        return exports.StudiesApiFp(this.configuration).getStudiesJoined(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, sort, limit, offset, userId, correlationCoefficient, updatedAt, outcomesOfInterest, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Get Study
     * @summary Get Study
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
        return exports.StudiesApiFp(this.configuration).getStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(this.fetch, this.basePath);
    }
    /**
     * Anonymously share measurements for specified variables
     * @summary Join a Study
     * @param {string} [studyId] Client id for the study you want
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options) {
        return exports.StudiesApiFp(this.configuration).joinStudy(studyId, causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * I am really good at finding correlations and even compensating for various onset delays and durations of action. However, you are much better than me at knowing if there's a way that a given factor could plausibly influence an outcome. You can help me learn and get better at my predictions by pressing the thumbs down button for relationships that you think are coincidences and thumbs up once that make logic sense.
     * @summary Post or update vote
     * @param {Vote} body Contains the cause variable, effect variable, and vote value.
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    postVote(body, userId, options) {
        return exports.StudiesApiFp(this.configuration).postVote(body, userId, options)(this.fetch, this.basePath);
    }
    /**
     * Make a study and all related measurements publicly visible by anyone
     * @summary Publish Your Study
     * @param {string} [causeVariableName] Deprecated: Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [effectVariableName] Deprecated: Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [causeVariableId] Variable id of the hypothetical predictor variable.  Ex: 1398
     * @param {number} [effectVariableId] Variable id of the outcome variable of interest.  Ex: 1398
     * @param {string} [predictorVariableName] Name of the hypothetical predictor variable.  Ex: Sleep Duration
     * @param {string} [outcomeVariableName] Name of the outcome variable of interest.  Ex: Overall Mood
     * @param {number} [userId] User&#39;s id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {string} [studyId] Client id for the study you want
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudiesApi
     */
    publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options) {
        return exports.StudiesApiFp(this.configuration).publishStudy(causeVariableName, effectVariableName, causeVariableId, effectVariableId, predictorVariableName, outcomeVariableName, userId, clientId, includeCharts, recalculate, studyId, options)(this.fetch, this.basePath);
    }
}
exports.StudiesApi = StudiesApi;
/**
 * UnitsApi - fetch parameter creator
 * @export
 */
exports.UnitsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
         * @summary Get unit categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitCategories(options = {}) {
            const localVarPath = `/v3/unitCategories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the available measurement units
         * @summary Get units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnits(options = {}) {
            const localVarPath = `/v3/units`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UnitsApi - functional programming interface
 * @export
 */
exports.UnitsApiFp = function (configuration) {
    return {
        /**
         * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
         * @summary Get unit categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitCategories(options) {
            const localVarFetchArgs = exports.UnitsApiFetchParamCreator(configuration).getUnitCategories(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a list of the available measurement units
         * @summary Get units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnits(options) {
            const localVarFetchArgs = exports.UnitsApiFetchParamCreator(configuration).getUnits(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * UnitsApi - factory interface
 * @export
 */
exports.UnitsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
         * @summary Get unit categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnitCategories(options) {
            return exports.UnitsApiFp(configuration).getUnitCategories(options)(fetch, basePath);
        },
        /**
         * Get a list of the available measurement units
         * @summary Get units
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnits(options) {
            return exports.UnitsApiFp(configuration).getUnits(options)(fetch, basePath);
        },
    };
};
/**
 * UnitsApi - object-oriented interface
 * @export
 * @class UnitsApi
 * @extends {BaseAPI}
 */
class UnitsApi extends BaseAPI {
    /**
     * Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.
     * @summary Get unit categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    getUnitCategories(options) {
        return exports.UnitsApiFp(this.configuration).getUnitCategories(options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of the available measurement units
     * @summary Get units
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    getUnits(options) {
        return exports.UnitsApiFp(this.configuration).getUnits(options)(this.fetch, this.basePath);
    }
}
exports.UnitsApi = UnitsApi;
/**
 * UserApi - fetch parameter creator
 * @export
 */
exports.UserApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Delete user account. Only the client app that created a user can delete that user.
         * @summary Delete user
         * @param {string} reason Ex: I hate you!
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(reason, clientId, options = {}) {
            // verify required parameter 'reason' is not null or undefined
            if (reason === null || reason === undefined) {
                throw new RequiredError('reason', 'Required parameter reason was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/v3/user/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["writemeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (reason !== undefined) {
                localVarQueryParameter['reason'] = reason;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns user info.  If no userId is specified, returns info for currently authenticated user
         * @summary Get user info
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {boolean} [includeAuthorizedClients] Return list of apps, studies, and individuals with access to user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options = {}) {
            const localVarPath = `/v3/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }
            if (clientUserId !== undefined) {
                localVarQueryParameter['clientUserId'] = clientUserId;
            }
            if (log !== undefined) {
                localVarQueryParameter['log'] = log;
            }
            if (pwd !== undefined) {
                localVarQueryParameter['pwd'] = pwd;
            }
            if (includeAuthorizedClients !== undefined) {
                localVarQueryParameter['includeAuthorizedClients'] = includeAuthorizedClients;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UserBlogs
         * @summary Get UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/userBlogs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns users who have granted access to their data
         * @summary Get users who shared data
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options = {}) {
            const localVarPath = `/v3/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }
            if (clientUserId !== undefined) {
                localVarQueryParameter['clientUserId'] = clientUserId;
            }
            if (log !== undefined) {
                localVarQueryParameter['log'] = log;
            }
            if (pwd !== undefined) {
                localVarQueryParameter['pwd'] = pwd;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post UserBlogs
         * @summary Post UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/userBlogs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post UserSettings
         * @summary Post UserSettings
         * @param {User} body User settings to update
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSettings(body, clientId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postUserSettings.');
            }
            const localVarPath = `/v3/userSettings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
exports.UserApiFp = function (configuration) {
    return {
        /**
         * Delete user account. Only the client app that created a user can delete that user.
         * @summary Delete user
         * @param {string} reason Ex: I hate you!
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(reason, clientId, options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).deleteUser(reason, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns user info.  If no userId is specified, returns info for currently authenticated user
         * @summary Get user info
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {boolean} [includeAuthorizedClients] Return list of apps, studies, and individuals with access to user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get UserBlogs
         * @summary Get UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns users who have granted access to their data
         * @summary Get users who shared data
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post UserBlogs
         * @summary Post UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post UserSettings
         * @summary Post UserSettings
         * @param {User} body User settings to update
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSettings(body, clientId, options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).postUserSettings(body, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
exports.UserApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Delete user account. Only the client app that created a user can delete that user.
         * @summary Delete user
         * @param {string} reason Ex: I hate you!
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(reason, clientId, options) {
            return exports.UserApiFp(configuration).deleteUser(reason, clientId, options)(fetch, basePath);
        },
        /**
         * Returns user info.  If no userId is specified, returns info for currently authenticated user
         * @summary Get user info
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {boolean} [includeAuthorizedClients] Return list of apps, studies, and individuals with access to user data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options) {
            return exports.UserApiFp(configuration).getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options)(fetch, basePath);
        },
        /**
         * Get UserBlogs
         * @summary Get UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.UserApiFp(configuration).getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Returns users who have granted access to their data
         * @summary Get users who shared data
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [appVersion] Ex: 2.1.1.0
         * @param {number} [clientUserId] Ex: 74802
         * @param {string} [log] Username or email
         * @param {string} [pwd] User password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options) {
            return exports.UserApiFp(configuration).getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options)(fetch, basePath);
        },
        /**
         * Post UserBlogs
         * @summary Post UserBlogs
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.UserApiFp(configuration).postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post UserSettings
         * @summary Post UserSettings
         * @param {User} body User settings to update
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSettings(body, clientId, options) {
            return exports.UserApiFp(configuration).postUserSettings(body, clientId, options)(fetch, basePath);
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends BaseAPI {
    /**
     * Delete user account. Only the client app that created a user can delete that user.
     * @summary Delete user
     * @param {string} reason Ex: I hate you!
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    deleteUser(reason, clientId, options) {
        return exports.UserApiFp(this.configuration).deleteUser(reason, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Returns user info.  If no userId is specified, returns info for currently authenticated user
     * @summary Get user info
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {number} [clientUserId] Ex: 74802
     * @param {string} [log] Username or email
     * @param {string} [pwd] User password
     * @param {boolean} [includeAuthorizedClients] Return list of apps, studies, and individuals with access to user data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options) {
        return exports.UserApiFp(this.configuration).getUser(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, includeAuthorizedClients, options)(this.fetch, this.basePath);
    }
    /**
     * Get UserBlogs
     * @summary Get UserBlogs
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.UserApiFp(this.configuration).getUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Returns users who have granted access to their data
     * @summary Get users who shared data
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [appVersion] Ex: 2.1.1.0
     * @param {number} [clientUserId] Ex: 74802
     * @param {string} [log] Username or email
     * @param {string} [pwd] User password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options) {
        return exports.UserApiFp(this.configuration).getUsers(userId, createdAt, updatedAt, limit, offset, sort, clientId, appVersion, clientUserId, log, pwd, options)(this.fetch, this.basePath);
    }
    /**
     * Post UserBlogs
     * @summary Post UserBlogs
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.UserApiFp(this.configuration).postUserBlogs(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post UserSettings
     * @summary Post UserSettings
     * @param {User} body User settings to update
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    postUserSettings(body, clientId, options) {
        return exports.UserApiFp(this.configuration).postUserSettings(body, clientId, options)(this.fetch, this.basePath);
    }
}
exports.UserApi = UserApi;
/**
 * VariablesApi - fetch parameter creator
 * @export
 */
exports.VariablesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Delete previously created user tags or ingredients.
         * @summary Delete user tag or ingredient
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(taggedVariableId, tagVariableId, options = {}) {
            const localVarPath = `/v3/userTags/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (taggedVariableId !== undefined) {
                localVarQueryParameter['taggedVariableId'] = taggedVariableId;
            }
            if (tagVariableId !== undefined) {
                localVarQueryParameter['tagVariableId'] = tagVariableId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can delete all of their measurements for a variable
         * @summary Delete All Measurements For Variable
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserVariable(variableId, options = {}) {
            // verify required parameter 'variableId' is not null or undefined
            if (variableId === null || variableId === undefined) {
                throw new RequiredError('variableId', 'Required parameter variableId was null or undefined when calling deleteUserVariable.');
            }
            const localVarPath = `/v3/userVariables/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UserVariableDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(variableId || {}) : (variableId || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
         * @summary Variable categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableCategories(options = {}) {
            const localVarPath = `/v3/variableCategories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
         * @summary Get variables along with related user-specific analysis settings and statistics
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {string} [numberOfRawMeasurements] Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
         * @param {number} [userId] User&#39;s id
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [name] Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Common variable id
         * @param {string} [lastSourceName] Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [upc] UPC or other barcode scan result
         * @param {string} [effectOrCause] Provided variable is the effect or cause
         * @param {string} [publicEffectOrCause] Ex:
         * @param {boolean} [exactMatch] Require exact match
         * @param {number} [variableCategoryId] Ex: 13
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [joinVariableId] Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
         * @param {number} [parentUserTagVariableId] Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [childUserTagVariableId] Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [ingredientUserTagVariableId] Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {number} [ingredientOfUserTagVariableId] Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {boolean} [commonOnly] Return only public and aggregated common variable data instead of user-specific variables
         * @param {boolean} [userOnly] Return only user-specific variables and data, excluding common aggregated variable data
         * @param {boolean} [includeTags] Return parent, child, duplicate, and ingredient variables
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {number} [variableId] Ex: 13
         * @param {boolean} [concise] Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
         * @param {boolean} [refresh] Regenerate charts instead of getting from the cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options = {}) {
            const localVarPath = `/v3/variables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (includeCharts !== undefined) {
                localVarQueryParameter['includeCharts'] = includeCharts;
            }
            if (numberOfRawMeasurements !== undefined) {
                localVarQueryParameter['numberOfRawMeasurements'] = numberOfRawMeasurements;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (variableName !== undefined) {
                localVarQueryParameter['variableName'] = variableName;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (sourceName !== undefined) {
                localVarQueryParameter['sourceName'] = sourceName;
            }
            if (earliestMeasurementTime !== undefined) {
                localVarQueryParameter['earliestMeasurementTime'] = earliestMeasurementTime;
            }
            if (latestMeasurementTime !== undefined) {
                localVarQueryParameter['latestMeasurementTime'] = latestMeasurementTime;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (lastSourceName !== undefined) {
                localVarQueryParameter['lastSourceName'] = lastSourceName;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (includePublic !== undefined) {
                localVarQueryParameter['includePublic'] = includePublic;
            }
            if (manualTracking !== undefined) {
                localVarQueryParameter['manualTracking'] = manualTracking;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (upc !== undefined) {
                localVarQueryParameter['upc'] = upc;
            }
            if (effectOrCause !== undefined) {
                localVarQueryParameter['effectOrCause'] = effectOrCause;
            }
            if (publicEffectOrCause !== undefined) {
                localVarQueryParameter['publicEffectOrCause'] = publicEffectOrCause;
            }
            if (exactMatch !== undefined) {
                localVarQueryParameter['exactMatch'] = exactMatch;
            }
            if (variableCategoryId !== undefined) {
                localVarQueryParameter['variableCategoryId'] = variableCategoryId;
            }
            if (includePrivate !== undefined) {
                localVarQueryParameter['includePrivate'] = includePrivate;
            }
            if (searchPhrase !== undefined) {
                localVarQueryParameter['searchPhrase'] = searchPhrase;
            }
            if (synonyms !== undefined) {
                localVarQueryParameter['synonyms'] = synonyms;
            }
            if (taggedVariableId !== undefined) {
                localVarQueryParameter['taggedVariableId'] = taggedVariableId;
            }
            if (tagVariableId !== undefined) {
                localVarQueryParameter['tagVariableId'] = tagVariableId;
            }
            if (joinVariableId !== undefined) {
                localVarQueryParameter['joinVariableId'] = joinVariableId;
            }
            if (parentUserTagVariableId !== undefined) {
                localVarQueryParameter['parentUserTagVariableId'] = parentUserTagVariableId;
            }
            if (childUserTagVariableId !== undefined) {
                localVarQueryParameter['childUserTagVariableId'] = childUserTagVariableId;
            }
            if (ingredientUserTagVariableId !== undefined) {
                localVarQueryParameter['ingredientUserTagVariableId'] = ingredientUserTagVariableId;
            }
            if (ingredientOfUserTagVariableId !== undefined) {
                localVarQueryParameter['ingredientOfUserTagVariableId'] = ingredientOfUserTagVariableId;
            }
            if (commonOnly !== undefined) {
                localVarQueryParameter['commonOnly'] = commonOnly;
            }
            if (userOnly !== undefined) {
                localVarQueryParameter['userOnly'] = userOnly;
            }
            if (includeTags !== undefined) {
                localVarQueryParameter['includeTags'] = includeTags;
            }
            if (recalculate !== undefined) {
                localVarQueryParameter['recalculate'] = recalculate;
            }
            if (variableId !== undefined) {
                localVarQueryParameter['variableId'] = variableId;
            }
            if (concise !== undefined) {
                localVarQueryParameter['concise'] = concise;
            }
            if (refresh !== undefined) {
                localVarQueryParameter['refresh'] = refresh;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
         * @summary Post or update user tags or ingredients
         * @param {UserTag} body Contains the new user tag data
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserTags(body, userId, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling postUserTags.');
            }
            const localVarPath = `/v3/userTags`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UserTag" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
         * @summary Update User Settings for a Variable
         * @param {Array<Variable>} userVariables Variable user settings data
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {boolean} [exactMatch] Require exact match
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {number} [variableCategoryId] Ex: 13
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options = {}) {
            // verify required parameter 'userVariables' is not null or undefined
            if (userVariables === null || userVariables === undefined) {
                throw new RequiredError('userVariables', 'Required parameter userVariables was null or undefined when calling postUserVariables.');
            }
            const localVarPath = `/v3/variables`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (includePrivate !== undefined) {
                localVarQueryParameter['includePrivate'] = includePrivate;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            if (includePublic !== undefined) {
                localVarQueryParameter['includePublic'] = includePublic;
            }
            if (searchPhrase !== undefined) {
                localVarQueryParameter['searchPhrase'] = searchPhrase;
            }
            if (exactMatch !== undefined) {
                localVarQueryParameter['exactMatch'] = exactMatch;
            }
            if (manualTracking !== undefined) {
                localVarQueryParameter['manualTracking'] = manualTracking;
            }
            if (variableCategoryName !== undefined) {
                localVarQueryParameter['variableCategoryName'] = variableCategoryName;
            }
            if (variableCategoryId !== undefined) {
                localVarQueryParameter['variableCategoryId'] = variableCategoryId;
            }
            if (synonyms !== undefined) {
                localVarQueryParameter['synonyms'] = synonyms;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("Array&lt;Variable&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(userVariables || {}) : (userVariables || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset user settings for a variable to defaults
         * @summary Reset user settings for a variable to defaults
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserVariableSettings(variableId, options = {}) {
            // verify required parameter 'variableId' is not null or undefined
            if (variableId === null || variableId === undefined) {
                throw new RequiredError('variableId', 'Required parameter variableId was null or undefined when calling resetUserVariableSettings.');
            }
            const localVarPath = `/v3/userVariables/reset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["basic"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("UserVariableDelete" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(variableId || {}) : (variableId || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * VariablesApi - functional programming interface
 * @export
 */
exports.VariablesApiFp = function (configuration) {
    return {
        /**
         * Delete previously created user tags or ingredients.
         * @summary Delete user tag or ingredient
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(taggedVariableId, tagVariableId, options) {
            const localVarFetchArgs = exports.VariablesApiFetchParamCreator(configuration).deleteUserTag(taggedVariableId, tagVariableId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Users can delete all of their measurements for a variable
         * @summary Delete All Measurements For Variable
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserVariable(variableId, options) {
            const localVarFetchArgs = exports.VariablesApiFetchParamCreator(configuration).deleteUserVariable(variableId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
         * @summary Variable categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableCategories(options) {
            const localVarFetchArgs = exports.VariablesApiFetchParamCreator(configuration).getVariableCategories(options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
         * @summary Get variables along with related user-specific analysis settings and statistics
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {string} [numberOfRawMeasurements] Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
         * @param {number} [userId] User&#39;s id
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [name] Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Common variable id
         * @param {string} [lastSourceName] Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [upc] UPC or other barcode scan result
         * @param {string} [effectOrCause] Provided variable is the effect or cause
         * @param {string} [publicEffectOrCause] Ex:
         * @param {boolean} [exactMatch] Require exact match
         * @param {number} [variableCategoryId] Ex: 13
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [joinVariableId] Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
         * @param {number} [parentUserTagVariableId] Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [childUserTagVariableId] Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [ingredientUserTagVariableId] Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {number} [ingredientOfUserTagVariableId] Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {boolean} [commonOnly] Return only public and aggregated common variable data instead of user-specific variables
         * @param {boolean} [userOnly] Return only user-specific variables and data, excluding common aggregated variable data
         * @param {boolean} [includeTags] Return parent, child, duplicate, and ingredient variables
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {number} [variableId] Ex: 13
         * @param {boolean} [concise] Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
         * @param {boolean} [refresh] Regenerate charts instead of getting from the cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options) {
            const localVarFetchArgs = exports.VariablesApiFetchParamCreator(configuration).getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
         * @summary Post or update user tags or ingredients
         * @param {UserTag} body Contains the new user tag data
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserTags(body, userId, options) {
            const localVarFetchArgs = exports.VariablesApiFetchParamCreator(configuration).postUserTags(body, userId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
         * @summary Update User Settings for a Variable
         * @param {Array<Variable>} userVariables Variable user settings data
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {boolean} [exactMatch] Require exact match
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {number} [variableCategoryId] Ex: 13
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options) {
            const localVarFetchArgs = exports.VariablesApiFetchParamCreator(configuration).postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reset user settings for a variable to defaults
         * @summary Reset user settings for a variable to defaults
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserVariableSettings(variableId, options) {
            const localVarFetchArgs = exports.VariablesApiFetchParamCreator(configuration).resetUserVariableSettings(variableId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * VariablesApi - factory interface
 * @export
 */
exports.VariablesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Delete previously created user tags or ingredients.
         * @summary Delete user tag or ingredient
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserTag(taggedVariableId, tagVariableId, options) {
            return exports.VariablesApiFp(configuration).deleteUserTag(taggedVariableId, tagVariableId, options)(fetch, basePath);
        },
        /**
         * Users can delete all of their measurements for a variable
         * @summary Delete All Measurements For Variable
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserVariable(variableId, options) {
            return exports.VariablesApiFp(configuration).deleteUserVariable(variableId, options)(fetch, basePath);
        },
        /**
         * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
         * @summary Variable categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariableCategories(options) {
            return exports.VariablesApiFp(configuration).getVariableCategories(options)(fetch, basePath);
        },
        /**
         * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
         * @summary Get variables along with related user-specific analysis settings and statistics
         * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
         * @param {string} [numberOfRawMeasurements] Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
         * @param {number} [userId] User&#39;s id
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {string} [name] Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
         * @param {string} [variableName] Name of the variable you want measurements for
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
         * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Common variable id
         * @param {string} [lastSourceName] Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {string} [upc] UPC or other barcode scan result
         * @param {string} [effectOrCause] Provided variable is the effect or cause
         * @param {string} [publicEffectOrCause] Ex:
         * @param {boolean} [exactMatch] Require exact match
         * @param {number} [variableCategoryId] Ex: 13
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
         * @param {number} [joinVariableId] Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
         * @param {number} [parentUserTagVariableId] Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [childUserTagVariableId] Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
         * @param {number} [ingredientUserTagVariableId] Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {number} [ingredientOfUserTagVariableId] Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
         * @param {boolean} [commonOnly] Return only public and aggregated common variable data instead of user-specific variables
         * @param {boolean} [userOnly] Return only user-specific variables and data, excluding common aggregated variable data
         * @param {boolean} [includeTags] Return parent, child, duplicate, and ingredient variables
         * @param {boolean} [recalculate] Recalculate instead of using cached analysis
         * @param {number} [variableId] Ex: 13
         * @param {boolean} [concise] Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
         * @param {boolean} [refresh] Regenerate charts instead of getting from the cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options) {
            return exports.VariablesApiFp(configuration).getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options)(fetch, basePath);
        },
        /**
         * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
         * @summary Post or update user tags or ingredients
         * @param {UserTag} body Contains the new user tag data
         * @param {number} [userId] User&#39;s id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserTags(body, userId, options) {
            return exports.VariablesApiFp(configuration).postUserTags(body, userId, options)(fetch, basePath);
        },
        /**
         * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
         * @summary Update User Settings for a Variable
         * @param {Array<Variable>} userVariables Variable user settings data
         * @param {boolean} [includePrivate] Include user-specific variables in results
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {boolean} [includePublic] Include variables the user has no measurements for
         * @param {string} [searchPhrase] Ex: %Body Fat%
         * @param {boolean} [exactMatch] Require exact match
         * @param {boolean} [manualTracking] Only include variables tracked manually by the user
         * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
         * @param {number} [variableCategoryId] Ex: 13
         * @param {string} [synonyms] Ex: McDonalds hotcake
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options) {
            return exports.VariablesApiFp(configuration).postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options)(fetch, basePath);
        },
        /**
         * Reset user settings for a variable to defaults
         * @summary Reset user settings for a variable to defaults
         * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserVariableSettings(variableId, options) {
            return exports.VariablesApiFp(configuration).resetUserVariableSettings(variableId, options)(fetch, basePath);
        },
    };
};
/**
 * VariablesApi - object-oriented interface
 * @export
 * @class VariablesApi
 * @extends {BaseAPI}
 */
class VariablesApi extends BaseAPI {
    /**
     * Delete previously created user tags or ingredients.
     * @summary Delete user tag or ingredient
     * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    deleteUserTag(taggedVariableId, tagVariableId, options) {
        return exports.VariablesApiFp(this.configuration).deleteUserTag(taggedVariableId, tagVariableId, options)(this.fetch, this.basePath);
    }
    /**
     * Users can delete all of their measurements for a variable
     * @summary Delete All Measurements For Variable
     * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    deleteUserVariable(variableId, options) {
        return exports.VariablesApiFp(this.configuration).deleteUserVariable(variableId, options)(this.fetch, this.basePath);
    }
    /**
     * The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Goals.
     * @summary Variable categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    getVariableCategories(options) {
        return exports.VariablesApiFp(this.configuration).getVariableCategories(options)(this.fetch, this.basePath);
    }
    /**
     * Get variables. If the user has specified variable settings, these are provided instead of the common variable defaults.
     * @summary Get variables along with related user-specific analysis settings and statistics
     * @param {boolean} [includeCharts] Highcharts configs that can be used if you have highcharts.js included on the page.  This only works if the id or name query parameter is also provided.
     * @param {string} [numberOfRawMeasurements] Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.
     * @param {number} [userId] User&#39;s id
     * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param {string} [name] Name of the variable. To get results matching a substring, add % as a wildcard as the first and/or last character of a query string parameter. In order to get variables that contain &#x60;Mood&#x60;, the following query should be used: ?variableName&#x3D;%Mood%
     * @param {string} [variableName] Name of the variable you want measurements for
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {string} [sourceName] ID of the source you want measurements for (supports exact name match only)
     * @param {string} [earliestMeasurementTime] Excluded records with measurement times earlier than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {string} [latestMeasurementTime] Excluded records with measurement times later than this value. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss  datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Common variable id
     * @param {string} [lastSourceName] Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {boolean} [includePublic] Include variables the user has no measurements for
     * @param {boolean} [manualTracking] Only include variables tracked manually by the user
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {string} [upc] UPC or other barcode scan result
     * @param {string} [effectOrCause] Provided variable is the effect or cause
     * @param {string} [publicEffectOrCause] Ex:
     * @param {boolean} [exactMatch] Require exact match
     * @param {number} [variableCategoryId] Ex: 13
     * @param {boolean} [includePrivate] Include user-specific variables in results
     * @param {string} [searchPhrase] Ex: %Body Fat%
     * @param {string} [synonyms] Ex: McDonalds hotcake
     * @param {number} [taggedVariableId] Id of the tagged variable (i.e. Lollipop) you would like to get variables it can be tagged with (i.e. Sugar).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {number} [tagVariableId] Id of the tag variable (i.e. Sugar) you would like to get variables it can be tagged to (i.e. Lollipop).  Converted measurements of the tagged variable are included in analysis of the tag variable (i.e. ingredient).
     * @param {number} [joinVariableId] Id of the variable you would like to get variables that can be joined to.  This is used to merge duplicate variables.   If joinVariableId is specified, this returns only variables eligible to be joined to the variable specified by the joinVariableId.
     * @param {number} [parentUserTagVariableId] Id of the parent category variable (i.e. Fruit) you would like to get eligible child sub-type variables (i.e. Apple) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple.  When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
     * @param {number} [childUserTagVariableId] Id of the child sub-type variable (i.e. Apple) you would like to get eligible parent variables (i.e. Fruit) for.  Child variable measurements will be included in analysis of the parent variable.  For instance, a child sub-type of the parent category Fruit could be Apple. When Apple is tagged with the parent category Fruit, Apple measurements will be included when Fruit is analyzed.
     * @param {number} [ingredientUserTagVariableId] Id of the ingredient variable (i.e. Fructose)  you would like to get eligible ingredientOf variables (i.e. Apple) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
     * @param {number} [ingredientOfUserTagVariableId] Id of the ingredientOf variable (i.e. Apple) you would like to get eligible ingredient variables (i.e. Fructose) for.  IngredientOf variable measurements will be included in analysis of the ingredient variable.  For instance, a ingredientOf of variable Fruit could be Apple.
     * @param {boolean} [commonOnly] Return only public and aggregated common variable data instead of user-specific variables
     * @param {boolean} [userOnly] Return only user-specific variables and data, excluding common aggregated variable data
     * @param {boolean} [includeTags] Return parent, child, duplicate, and ingredient variables
     * @param {boolean} [recalculate] Recalculate instead of using cached analysis
     * @param {number} [variableId] Ex: 13
     * @param {boolean} [concise] Only return field required for variable auto-complete searches.  The smaller size allows for storing more variable results locally reducing API requests.
     * @param {boolean} [refresh] Regenerate charts instead of getting from the cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options) {
        return exports.VariablesApiFp(this.configuration).getVariables(includeCharts, numberOfRawMeasurements, userId, variableCategoryName, name, variableName, updatedAt, sourceName, earliestMeasurementTime, latestMeasurementTime, id, lastSourceName, limit, offset, sort, includePublic, manualTracking, clientId, upc, effectOrCause, publicEffectOrCause, exactMatch, variableCategoryId, includePrivate, searchPhrase, synonyms, taggedVariableId, tagVariableId, joinVariableId, parentUserTagVariableId, childUserTagVariableId, ingredientUserTagVariableId, ingredientOfUserTagVariableId, commonOnly, userOnly, includeTags, recalculate, variableId, concise, refresh, options)(this.fetch, this.basePath);
    }
    /**
     * This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.
     * @summary Post or update user tags or ingredients
     * @param {UserTag} body Contains the new user tag data
     * @param {number} [userId] User&#39;s id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    postUserTags(body, userId, options) {
        return exports.VariablesApiFp(this.configuration).postUserTags(body, userId, options)(this.fetch, this.basePath);
    }
    /**
     * Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.
     * @summary Update User Settings for a Variable
     * @param {Array<Variable>} userVariables Variable user settings data
     * @param {boolean} [includePrivate] Include user-specific variables in results
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {boolean} [includePublic] Include variables the user has no measurements for
     * @param {string} [searchPhrase] Ex: %Body Fat%
     * @param {boolean} [exactMatch] Require exact match
     * @param {boolean} [manualTracking] Only include variables tracked manually by the user
     * @param {string} [variableCategoryName] Options: Activities, Books, Causes of Illness, Cognitive Performance, Conditions, Emotions, Environment, Foods, Location, Miscellaneous, Movies and TV, Music, Nutrients, Payments, Physical Activity, Physique, Sleep, Social Interactions, Software, Symptoms, Treatments, Vital Signs, Goals
     * @param {number} [variableCategoryId] Ex: 13
     * @param {string} [synonyms] Ex: McDonalds hotcake
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options) {
        return exports.VariablesApiFp(this.configuration).postUserVariables(userVariables, includePrivate, clientId, includePublic, searchPhrase, exactMatch, manualTracking, variableCategoryName, variableCategoryId, synonyms, options)(this.fetch, this.basePath);
    }
    /**
     * Reset user settings for a variable to defaults
     * @summary Reset user settings for a variable to defaults
     * @param {UserVariableDelete} variableId Id of the variable whose measurements should be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariablesApi
     */
    resetUserVariableSettings(variableId, options) {
        return exports.VariablesApiFp(this.configuration).resetUserVariableSettings(variableId, options)(this.fetch, this.basePath);
    }
}
exports.VariablesApi = VariablesApi;
/**
 * XprofileApi - fetch parameter creator
 * @export
 */
exports.XprofileApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get XprofileData
         * @summary Get XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/xprofileData`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get XprofileFields
         * @summary Get XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/xprofileFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get XprofileGroups
         * @summary Get XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/xprofileGroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post XprofileData
         * @summary Post XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/xprofileData`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post XprofileFields
         * @summary Post XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/xprofileFields`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Post XprofileGroups
         * @summary Post XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options = {}) {
            const localVarPath = `/v3/xprofileGroups`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication access_token required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? configuration.apiKey("access_token")
                    : configuration.apiKey;
                localVarQueryParameter["access_token"] = localVarApiKeyValue;
            }
            // authentication quantimodo_oauth2 required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("quantimodo_oauth2", ["readmeasurements"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }
            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * XprofileApi - functional programming interface
 * @export
 */
exports.XprofileApiFp = function (configuration) {
    return {
        /**
         * Get XprofileData
         * @summary Get XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.XprofileApiFetchParamCreator(configuration).getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get XprofileFields
         * @summary Get XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.XprofileApiFetchParamCreator(configuration).getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get XprofileGroups
         * @summary Get XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.XprofileApiFetchParamCreator(configuration).getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post XprofileData
         * @summary Post XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.XprofileApiFetchParamCreator(configuration).postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post XprofileFields
         * @summary Post XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.XprofileApiFetchParamCreator(configuration).postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Post XprofileGroups
         * @summary Post XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            const localVarFetchArgs = exports.XprofileApiFetchParamCreator(configuration).postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options);
            return (fetch = portableFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
/**
 * XprofileApi - factory interface
 * @export
 */
exports.XprofileApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get XprofileData
         * @summary Get XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.XprofileApiFp(configuration).getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get XprofileFields
         * @summary Get XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.XprofileApiFp(configuration).getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Get XprofileGroups
         * @summary Get XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.XprofileApiFp(configuration).getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post XprofileData
         * @summary Post XprofileData
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.XprofileApiFp(configuration).postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post XprofileFields
         * @summary Post XprofileFields
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.XprofileApiFp(configuration).postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
        /**
         * Post XprofileGroups
         * @summary Post XprofileGroups
         * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
         * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
         * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
         * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [userId] User&#39;s id
         * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
         * @param {number} [id] Id
         * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
            return exports.XprofileApiFp(configuration).postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(fetch, basePath);
        },
    };
};
/**
 * XprofileApi - object-oriented interface
 * @export
 * @class XprofileApi
 * @extends {BaseAPI}
 */
class XprofileApi extends BaseAPI {
    /**
     * Get XprofileData
     * @summary Get XprofileData
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.XprofileApiFp(this.configuration).getXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Get XprofileFields
     * @summary Get XprofileFields
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.XprofileApiFp(this.configuration).getXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Get XprofileGroups
     * @summary Get XprofileGroups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.XprofileApiFp(this.configuration).getXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post XprofileData
     * @summary Post XprofileData
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.XprofileApiFp(this.configuration).postXprofileData(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post XprofileFields
     * @summary Post XprofileFields
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.XprofileApiFp(this.configuration).postXprofileFields(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
    /**
     * Post XprofileGroups
     * @summary Post XprofileGroups
     * @param {string} [sort] Sort by one of the listed field names. If the field name is prefixed with &#x60;-&#x60;, it will sort in descending order.
     * @param {number} [limit] The LIMIT is used to limit the number of results returned. So if youhave 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.
     * @param {number} [offset] OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause.If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.
     * @param {string} [updatedAt] When the record was last updated. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [userId] User&#39;s id
     * @param {string} [createdAt] When the record was first created. Use UTC ISO 8601 YYYY-MM-DDThh:mm:ss datetime format. Time zone should be UTC and not local.
     * @param {number} [id] Id
     * @param {string} [clientId] Your QuantiModo client id can be obtained by creating an app at https://builder.quantimo.do
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof XprofileApi
     */
    postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options) {
        return exports.XprofileApiFp(this.configuration).postXprofileGroups(sort, limit, offset, updatedAt, userId, createdAt, id, clientId, options)(this.fetch, this.basePath);
    }
}
exports.XprofileApi = XprofileApi;
